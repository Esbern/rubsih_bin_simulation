from __future__ import annotations

import json
from pathlib import Path


def _write_notebook(path: Path, cells: list[dict]) -> None:
    nb = {
        "cells": cells,
        "metadata": {
            "kernelspec": {"display_name": "Python 3", "language": "python", "name": "python3"},
            "language_info": {"name": "python", "version": "3.11"},
        },
        "nbformat": 4,
        "nbformat_minor": 5,
    }
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(json.dumps(nb, indent=2, ensure_ascii=False), encoding="utf-8")


def main() -> None:
    root = Path(__file__).resolve().parents[1]

    mqtt_cells = [
        {
            "cell_type": "markdown",
            "id": "mqtt-intro",
            "metadata": {"id": "mqtt-intro", "language": "markdown"},
            "source": [
                "# Bin Dashboard — MQTT Live",
                "",
                "This notebook subscribes to the simulator’s MQTT bin status topics and plots fill % over time.",
                "",
                "## Prereqs",
                "- Create `.env` with `HIVEMQ_USERNAME` and `HIVEMQ_PASSWORD` (or export them)",
                "- Start the simulator in another terminal:",
                "",
                "```bash",
                "python -m simulated_city --steps 200",
                "```",
                "",
                "Install notebook dependencies:",
                "",
                "```bash",
                "python -m pip install -e \".[notebooks]\"",
                "```",
            ],
        },
        {
            "cell_type": "code",
            "id": "mqtt-imports",
            "metadata": {"id": "mqtt-imports", "language": "python"},
            "source": [
                "from __future__ import annotations",
                "",
                "import time",
                "",
                "import altair as alt",
                "import pandas as pd",
                "from IPython.display import clear_output, display",
                "",
                "from simulated_city.config import load_config",
                "from simulated_city.dashboard_data import (",
                "    drain_queue,",
                "    event_from_payload,",
                "    events_to_frame,",
                "    start_mqtt_listener,",
                "    stop_mqtt_listener,",
                ")",
            ],
        },
        {
            "cell_type": "code",
            "id": "mqtt-settings",
            "metadata": {"id": "mqtt-settings", "language": "python"},
            "source": [
                "cfg = load_config()",
                "TOPIC_FILTER = f\"{cfg.mqtt.base_topic}/bins/+/+/status\"",
                "",
                "ALERT_THRESHOLD = 80",
                "HISTORY_DAYS = 7  # Set None to show all data",
                "REFRESH_S = 2.0",
                "RUN_FOR_S = 60",
                "",
                "print('Broker:', f\"{cfg.mqtt.host}:{cfg.mqtt.port}\", 'tls=', cfg.mqtt.tls)",
                "print('Topic filter:', TOPIC_FILTER)",
            ],
        },
        {
            "cell_type": "code",
            "id": "mqtt-run",
            "metadata": {"id": "mqtt-run", "language": "python"},
            "source": [
                "# Starts a subscriber and renders a live chart for RUN_FOR_S seconds.",
                "# Tip: stop early via Kernel -> Interrupt.",
                "",
                "q, client = start_mqtt_listener(cfg.mqtt, TOPIC_FILTER)",
                "",
                "df = pd.DataFrame(",
                "    {",
                "        'ts': pd.Series(dtype='datetime64[ns, UTC]'),",
                "        'series': pd.Series(dtype='string'),",
                "        'fill_pct': pd.Series(dtype='int64'),",
                "        'timestep_index': pd.Series(dtype='int64'),",
                "        'event': pd.Series(dtype='string'),",
                "    }",
                ")",
                "",
                "t_end = time.time() + float(RUN_FOR_S)",
                "try:",
                "    while time.time() < t_end:",
                "        payloads = drain_queue(q)",
                "        new_events = []",
                "        for payload in payloads:",
                "            try:",
                "                new_events.append(event_from_payload(payload))",
                "            except Exception:",
                "                continue",
                "",
                "        if new_events:",
                "            df = pd.concat([df, events_to_frame(new_events)], ignore_index=True)",
                "            df = df.sort_values(['ts', 'series'], kind='mergesort')",
                "            df = df.drop_duplicates(subset=['ts', 'series', 'fill_pct', 'event'], keep='last').reset_index(drop=True)",
                "",
                "        view = df",
                "        if not view.empty:",
                "            init_ts = view.loc[view['event'] == 'init', 'ts'] if 'event' in view.columns else pd.Series(dtype='datetime64[ns, UTC]')",
                "            if not init_ts.empty:",
                "                view = view[view['ts'] >= init_ts.max()]",
                "",
                "            diffs = view.sort_values(['series', 'ts']).groupby('series')['fill_pct'].diff()",
                "            reset_rows = view.loc[diffs < 0, 'ts']",
                "            if not reset_rows.empty:",
                "                view = view[view['ts'] >= reset_rows.max()]",
                "",
                "            if HISTORY_DAYS is not None and not view.empty:",
                "                anchor = view['ts'].max()",
                "                cutoff = anchor - pd.Timedelta(days=int(HISTORY_DAYS))",
                "                view = view[view['ts'] >= cutoff]",
                "",
                "        clear_output(wait=True)",
                "        if view.empty:",
                "            print('Waiting for status events... (is the simulator running?)')",
                "        else:",
                "            latest = view.sort_values('ts').groupby('series').tail(1)",
                "            alerts = latest[latest['fill_pct'] >= int(ALERT_THRESHOLD)]",
                "            if not alerts.empty:",
                "                print('ALERT: Containers at or above threshold:')",
                "                for row in alerts.itertuples(index=False):",
                "                    print(f'  - {row.series} = {int(row.fill_pct)}%')",
                "            else:",
                "                print('All containers are below the alert threshold.')",
                "",
                "            wide = view.pivot_table(index='ts', columns='series', values='fill_pct', aggfunc='last').sort_index()",
                "            wide = wide.ffill().astype('float64')",
                "            long = wide.reset_index().melt(id_vars='ts', var_name='series', value_name='fill_pct').dropna()",
                "",
                "            chart = (",
                "                alt.Chart(long)",
                "                .mark_line(interpolate='step-after')",
                "                .encode(",
                "                    x=alt.X('ts:T', title=None),",
                "                    y=alt.Y('fill_pct:Q', title='Fill %', scale=alt.Scale(domain=[0, 100])),",
                "                    color=alt.Color('series:N', title=None),",
                "                    tooltip=[",
                "                        alt.Tooltip('ts:T', title='ts'),",
                "                        alt.Tooltip('series:N', title='bin'),",
                "                        alt.Tooltip('fill_pct:Q', title='fill_pct'),",
                "                    ],",
                "                )",
                "            ).properties(height=350)",
                "",
                "            display(chart)",
                "            display(latest[['ts', 'series', 'fill_pct']].sort_values('series').reset_index(drop=True))",
                "",
                "        time.sleep(float(REFRESH_S))",
                "finally:",
                "    stop_mqtt_listener(client)",
                "    print('Disconnected.')",
                "",
                "print('Live view finished.')",
            ],
        },
    ]

    log_cells = [
        {
            "cell_type": "markdown",
            "id": "log-intro",
            "metadata": {"id": "log-intro", "language": "markdown"},
            "source": [
                "# Bin Dashboard — Log File Viewer",
                "",
                "This notebook reads a simulator JSONL log file and plots bin fill % over time.",
                "",
                "Generate the log file:",
                "",
                "```bash",
                "python -m simulated_city --steps 500 --dry-run --log-file sim_status.jsonl",
                "```",
            ],
        },
        {
            "cell_type": "code",
            "id": "log-imports",
            "metadata": {"id": "log-imports", "language": "python"},
            "source": [
                "from __future__ import annotations",
                "",
                "from pathlib import Path",
                "",
                "import altair as alt",
                "import pandas as pd",
                "",
                "from simulated_city.dashboard_data import event_from_payload, events_to_frame, read_jsonl_all",
            ],
        },
        {
            "cell_type": "code",
            "id": "log-settings",
            "metadata": {"id": "log-settings", "language": "python"},
            "source": [
                "# VS Code notebooks usually run with CWD = repo root, but some setups use CWD = notebooks/.",
                "# So we try both locations.",
                "LOG_PATH = Path('sim_status.jsonl')",
                "if not LOG_PATH.exists():",
                "    LOG_PATH = Path('..') / 'sim_status.jsonl'",
                "",
                "ALERT_THRESHOLD = 80",
                "HISTORY_DAYS = 7  # Set None to show all",
                "LOG_PATH",
            ],
        },
        {
            "cell_type": "code",
            "id": "log-view",
            "metadata": {"id": "log-view", "language": "python"},
            "source": [
                "if not LOG_PATH.exists():",
                "    raise FileNotFoundError(",
                "        f'Log file not found: {LOG_PATH.resolve()}\\n\\n'",
                "        'Create it with: python -m simulated_city --steps 500 --dry-run --log-file sim_status.jsonl'",
                "    )",
                "",
                "payloads = read_jsonl_all(str(LOG_PATH))",
                "events = []",
                "for payload in payloads:",
                "    try:",
                "        events.append(event_from_payload(payload))",
                "    except Exception:",
                "        continue",
                "",
                "df = events_to_frame(events)",
                "df = df.sort_values(['ts', 'series'], kind='mergesort').reset_index(drop=True)",
                "",
                "if not df.empty and 'event' in df.columns:",
                "    init_ts = df.loc[df['event'] == 'init', 'ts']",
                "    if not init_ts.empty:",
                "        df = df[df['ts'] >= init_ts.max()].copy()",
                "",
                "if not df.empty and HISTORY_DAYS is not None:",
                "    anchor = df['ts'].max()",
                "    cutoff = anchor - pd.Timedelta(days=int(HISTORY_DAYS))",
                "    df = df[df['ts'] >= cutoff].copy()",
                "",
                "if df.empty:",
                "    print('No status events in the selected window.')",
                "else:",
                "    latest = df.sort_values('ts').groupby('series').tail(1)",
                "    alerts = latest[latest['fill_pct'] >= int(ALERT_THRESHOLD)]",
                "    if not alerts.empty:",
                "        print('ALERT: Containers at or above threshold:')",
                "        for row in alerts.itertuples(index=False):",
                "            print(f'  - {row.series} = {int(row.fill_pct)}%')",
                "    else:",
                "        print('All containers are below the alert threshold.')",
                "",
                "    wide = df.pivot_table(index='ts', columns='series', values='fill_pct', aggfunc='last').sort_index()",
                "    wide = wide.ffill().astype('float64')",
                "    long = wide.reset_index().melt(id_vars='ts', var_name='series', value_name='fill_pct').dropna()",
                "",
                "    chart = (",
                "        alt.Chart(long)",
                "        .mark_line(interpolate='step-after')",
                "        .encode(",
                "            x=alt.X('ts:T', title=None),",
                "            y=alt.Y('fill_pct:Q', title='Fill %', scale=alt.Scale(domain=[0, 100])),",
                "            color=alt.Color('series:N', title=None),",
                "            tooltip=[",
                "                alt.Tooltip('ts:T', title='ts'),",
                "                alt.Tooltip('series:N', title='bin'),",
                "                alt.Tooltip('fill_pct:Q', title='fill_pct'),",
                "            ],",
                "        )",
                "    ).properties(height=350)",
                "",
                "    chart",
            ],
        },
    ]

    _write_notebook(root / "notebooks" / "02_bin_dashboard_mqtt_live.ipynb", mqtt_cells)
    _write_notebook(root / "notebooks" / "03_bin_dashboard_logfile.ipynb", log_cells)


if __name__ == "__main__":
    main()
